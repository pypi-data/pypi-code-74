'''1.矩阵类型
1+行列式计算
3.r不为零
'''


def A(m, n):  # 输入矩阵
    lt = []
    try:
        for i in range(int(m)):
            a = input("空格分割，回车退出：")
            ls = list(map(eval, a.split()))
            lt.append(ls)
        for i in lt:
            if len(i) != int(n):
                raise
    except:
        print("矩阵内容输入错误,请重新输入！")
        lt = A(m, n)
    return lt


def q(A, m, n, k):  # 取k阶子式
    ls = []
    a = 1
    while a != m:
        ls.extend(eval("q{}(A, m, n, a)".format(k)))
        a += 1
    return ls


def q2(A, m, n, a):  # 辅助2阶子式
    ls = []
    try:
        for i in range(0, n):
            for j in range(i + 1, n):
                for k in range(a, m):
                    l = []
                    lt = []
                    lt.append(A[a - 1][i])
                    lt.append(A[a - 1][j])
                    l.append(lt)
                    lt = []
                    lt.append(A[k][i])
                    lt.append(A[k][j])
                    l.append(lt)
                    ls.append(l)
    except:
        ls = []
    return ls


def q3(A, m, n, a):  # 辅助3阶子式
    ls = []
    try:
        for i in range(0, n):
            for j in range(i + 1, n):
                for u in range(j + 1, n):  # 任取3行
                    for k in range(a, m):
                        for s in range(k + 1, m):  # 任取3列
                            l = []
                            lt = []
                            lt.append(A[a - 1][i])
                            lt.append(A[a - 1][j])
                            lt.append(A[a - 1][u])
                            l.append(lt)
                            lt = []
                            lt.append(A[k][i])
                            lt.append(A[k][j])
                            lt.append(A[k][u])
                            l.append(lt)
                            lt = []
                            lt.append(A[s][i])
                            lt.append(A[s][j])
                            lt.append(A[s][u])
                            l.append(lt)
                            ls.append(l)
    except:
        ls = []
    return ls


def q4(A, m, n, a):  # 辅助4阶子式
    ls = []
    try:
        for i in range(0, n):
            for j in range(i + 1, n):
                for u in range(j + 1, n):
                    for q in range(u + 1, n):  # 任取4行
                        for k in range(a, m):
                            for s in range(k + 1, m):
                                for x in range(s + 1, m):  # 任取4列
                                    l = []
                                    lt = []
                                    lt.append(A[a - 1][i])
                                    lt.append(A[a - 1][j])
                                    lt.append(A[a - 1][u])
                                    lt.append(A[a - 1][q])
                                    l.append(lt)
                                    lt = []
                                    lt.append(A[k][i])
                                    lt.append(A[k][j])
                                    lt.append(A[k][u])
                                    lt.append(A[k][q])
                                    l.append(lt)
                                    lt = []
                                    lt.append(A[s][i])
                                    lt.append(A[s][j])
                                    lt.append(A[s][u])
                                    lt.append(A[s][q])
                                    l.append(lt)
                                    lt = []
                                    lt.append(A[x][i])
                                    lt.append(A[x][j])
                                    lt.append(A[x][u])
                                    lt.append(A[x][q])
                                    l.append(lt)
                                    ls.append(l)
    except:
        ls = []
    return ls


def q5(A, m, n, a):  # 辅助5阶子式
    ls = []
    try:
        for i in range(0, n):
            for j in range(i + 1, n):
                for u in range(j + 1, n):
                    for q in range(u + 1, n):
                        for z in range(q + 1, n):  # 任取5行
                            for k in range(a, m):
                                for s in range(k + 1, m):
                                    for x in range(s + 1, m):
                                        for c in range(x + 1, m):  # 任取4列
                                            l = []
                                            lt = []
                                            lt.append(A[a - 1][i])
                                            lt.append(A[a - 1][j])
                                            lt.append(A[a - 1][u])
                                            lt.append(A[a - 1][q])
                                            lt.append(A[a - 1][z])
                                            l.append(lt)
                                            lt = []
                                            lt.append(A[k][i])
                                            lt.append(A[k][j])
                                            lt.append(A[k][u])
                                            lt.append(A[k][q])
                                            lt.append(A[k][z])
                                            l.append(lt)
                                            lt = []
                                            lt.append(A[s][i])
                                            lt.append(A[s][j])
                                            lt.append(A[s][u])
                                            lt.append(A[s][q])
                                            lt.append(A[s][z])
                                            l.append(lt)
                                            lt = []
                                            lt.append(A[x][i])
                                            lt.append(A[x][j])
                                            lt.append(A[x][u])
                                            lt.append(A[x][q])
                                            lt.append(A[x][z])
                                            l.append(lt)
                                            lt = []
                                            lt.append(A[c][i])
                                            lt.append(A[c][j])
                                            lt.append(A[c][u])
                                            lt.append(A[c][q])
                                            lt.append(A[c][z])
                                            l.append(lt)
                                            ls.append(l)
    except:
        ls = []
    return ls


def tao(n):  # 计算逆序数
    s = 0
    for i in range(len(n)):
        try:
            for a in range(i):
                if eval(n[i]) < eval(n[a]):
                    s += 1
        except:
            break
    return s


def Acou5(A):  # 计算5阶行列式
    s = 0
    for i in range(5):
        for j in range(5):
            for k in range(5):
                for u in range(5):
                    for q in range(5):
                        if i != j and j != k and i != k and i != u and j != u and k != u and i != q and j != q and u != q and k != q:
                            n = str(i + 1) + str(j + 1) + str(k + 1) + str(u + 1) + str(q + 1)
                            s += pow(-1, tao(n)) * A[0][i] * A[1][j] * A[2][k] * A[3][u] * A[4][q]
    return s


def Acou4(A):  # 计算4阶行列式
    s = 0
    for i in range(4):
        for j in range(4):
            for k in range(4):
                for u in range(4):
                    if i != j and j != k and i != k and i != u and j != u and k != u:
                        n = str(i + 1) + str(j + 1) + str(k + 1) + str(u + 1)
                        s += pow(-1, tao(n)) * A[0][i] * A[1][j] * A[2][k] * A[3][u]
    return s


def Acou3(A):  # 计算3阶行列式
    s = 0
    for i in range(3):
        for j in range(3):
            for k in range(3):
                if i != j and j != k and i != k:
                    n = str(i + 1) + str(j + 1) + str(k + 1)
                    s += pow(-1, tao(n)) * A[0][i] * A[1][j] * A[2][k]
    return s


def Acou2(A):  # 计算2阶行列式
    s = 0
    for i in range(2):
        for j in range(2):
            if i != j:
                a = str(i + 1) + str(j + 1)
                s += pow(-1, tao(a)) * A[0][i] * A[1][j]

    return s


def Ason1(A, m, n, a):  # 计算子式行列式#a为max(m,n)
    if a > 5:
        return "没有\n懒死你，自己算"
    else:
        try:
            if eval("q(A, m, n,{})".format(a)) == []:
                raise
            else:
                for i in eval("q(A, m, n,{})".format(a)):
                    if eval("Acou{}(i)".format(a)) != 0:

                        return a
                    else:
                        raise
        except:
            a -= 1
            if a > 1:
                return Ason1(A, m, n, a)
            else:
                for i in A:
                    for j in i:
                        if j != 0:
                            return 1
                        else:
                            return 0


def main():
    try:
        print("输入矩阵")
        m, n = eval(input("输入矩阵行数（回车退出）：")), eval(input("输入矩阵列数（回车退出）："))
        if m != int(m) or n != int(n):
            raise
        jz = A(m, n)
        a = max(m, n)
    except:
        print("行列数输入错误,重新输入！")
        main()
    else:
        try:
            print("该矩阵秩{}".format(Ason1(jz, m, n, a)))
        except:
            print("输入错误，请重新输入！2")
    main()


if __name__ == "__main__":
    print("#计算m*n矩阵的秩#")
    print("最好（含）5阶以内\n但是！\n以上也可以，放心使用")  #
    main()
